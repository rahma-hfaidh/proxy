{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { createHash } from \"crypto\";\nimport {\n  Request,\n  Response,\n  Headers,\n  HeadersInit,\n  CreateBody\n} from \"servie/dist/node\";\n\nexport interface SendOptions {\n  status?: number; // Change the default response status code (200).\n  headers?: HeadersInit; // Define headers to use for the response.\n  contentType?: string; // Define content length for the response.\n  contentLength?: number; // Define content length for the response.\n  mtime?: Date; // Define modtime for the response.\n  etag?: boolean | string; // Define ETag for the response.\n}\n\nconst CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/;\nconst TOKEN_LIST_REGEXP = / *, */;\nconst ZERO_LENGTH_ENTITY_TAG = toEntityTag(\"\");\n\n/**\n * Create an empty response.\n */\nexport function sendEmpty(req: Request, options: SendOptions = {}): Response {\n  return send(req, null, options);\n}\n\n/**\n * JSON response configuration.\n */\nexport interface JsonOptions extends SendOptions {\n  jsonSpaces?: string | number; // `JSON.stringify` spaces.\n  jsonReplacer?: (key: string, value: any) => string; // `JSON.stringify` replacer.\n}\n\n/**\n * Send JSON response.\n */\nexport function sendJson(\n  req: Request,\n  payload: boolean | string | number | object,\n  options: JsonOptions = {}\n): Response {\n  const contentType = options.contentType || \"application/json\";\n  const { status, headers, contentLength, mtime, etag } = options;\n  const data = JSON.stringify(\n    payload,\n    options.jsonReplacer,\n    options.jsonSpaces\n  );\n  return send(req, data, {\n    status,\n    headers,\n    contentType,\n    contentLength,\n    mtime,\n    etag\n  });\n}\n\n/**\n * Send the response as a stream.\n */\nexport function sendStream(\n  req: Request,\n  payload: CreateBody,\n  options: SendOptions = {}\n): Response {\n  const contentType = options.contentType || \"application/octet-stream\";\n  return send(req, payload, { ...options, contentType });\n}\n\n/**\n * Send as text response (defaults to `text/plain`).\n */\nexport function sendText(\n  req: Request,\n  payload: CreateBody,\n  options: SendOptions = {}\n): Response {\n  const contentType = options.contentType || \"text/plain\";\n  return send(req, payload, { ...options, contentType });\n}\n\n/**\n * Send as html response (`text/html`).\n */\nexport function sendHtml(\n  req: Request,\n  payload: CreateBody,\n  options: SendOptions = {}\n): Response {\n  const contentType = options.contentType || \"text/html\";\n  return send(req, payload, { ...options, contentType });\n}\n\n/**\n * Generate the response for Servie.\n */\nexport function send(\n  req: Request,\n  payload: CreateBody,\n  options: SendOptions = {}\n) {\n  let status = options.status || 200;\n  let body = req.method === \"HEAD\" ? undefined : payload;\n\n  const headers = new Headers(options.headers);\n  const { mtime, contentType, contentLength } = options;\n  const etag = computeEtag(body, options.etag);\n\n  if (fresh(req, etag, mtime)) {\n    status = 304;\n    body = undefined;\n  } else {\n    if (contentType) headers.set(\"Content-Type\", contentType);\n    if (contentLength) headers.set(\"Content-Length\", String(contentLength));\n  }\n\n  if (etag) headers.set(\"ETag\", etag);\n  if (mtime) headers.set(\"Last-Modified\", mtime.toUTCString());\n\n  return new Response(body, { status, headers });\n}\n\n/**\n * Compute etags when requested.\n */\nfunction computeEtag(body: CreateBody, etag?: boolean | string) {\n  if (typeof etag === \"string\") return etag;\n  if (!etag) return;\n  if (body === undefined || body === null) return ZERO_LENGTH_ENTITY_TAG;\n  if (typeof body === \"string\" || Buffer.isBuffer(body)) return entityTag(body);\n  throw new TypeError(\"Etag can only be computed on a string or buffer\");\n}\n\n/**\n * Create an ETag from the payload body.\n */\nexport function entityTag(body: string | Buffer): string | undefined {\n  return body.length === 0 ? ZERO_LENGTH_ENTITY_TAG : toEntityTag(body);\n}\n\n/**\n * Create an entity tag for cache identification.\n */\nfunction toEntityTag(body: string | Buffer): string {\n  const hash = createHash(\"sha256\")\n    .update(body)\n    .digest(\"base64\");\n\n  return `\"${hash}\"`;\n}\n\n/**\n * Check if a request is fresh.\n *\n * Reference: https://github.com/jshttp/fresh\n */\nfunction fresh(req: Request, etag?: string, mtime?: Date): boolean {\n  const ifNoneMatch = req.headers.get(\"if-none-match\");\n  const ifModifiedSince = req.headers.get(\"if-modified-since\");\n\n  if (!ifNoneMatch && !ifModifiedSince) return false;\n\n  const cacheControl = req.headers.get(\"cache-control\");\n\n  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n    return false;\n  }\n\n  if (ifNoneMatch && etag) {\n    const isFresh = ifNoneMatch.split(TOKEN_LIST_REGEXP).every(match => {\n      return match === etag;\n    });\n\n    if (isFresh) return true;\n  }\n\n  if (ifModifiedSince && mtime) {\n    const isFresh = mtime.getTime() <= Date.parse(ifModifiedSince);\n\n    if (isFresh) return true;\n  }\n\n  return false;\n}\n"]}