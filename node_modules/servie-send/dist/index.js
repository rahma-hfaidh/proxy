"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const node_1 = require("servie/dist/node");
const CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
const TOKEN_LIST_REGEXP = / *, */;
const ZERO_LENGTH_ENTITY_TAG = toEntityTag("");
/**
 * Create an empty response.
 */
function sendEmpty(req, options = {}) {
    return send(req, null, options);
}
exports.sendEmpty = sendEmpty;
/**
 * Send JSON response.
 */
function sendJson(req, payload, options = {}) {
    const contentType = options.contentType || "application/json";
    const { status, headers, contentLength, mtime, etag } = options;
    const data = JSON.stringify(payload, options.jsonReplacer, options.jsonSpaces);
    return send(req, data, {
        status,
        headers,
        contentType,
        contentLength,
        mtime,
        etag
    });
}
exports.sendJson = sendJson;
/**
 * Send the response as a stream.
 */
function sendStream(req, payload, options = {}) {
    const contentType = options.contentType || "application/octet-stream";
    return send(req, payload, Object.assign({}, options, { contentType }));
}
exports.sendStream = sendStream;
/**
 * Send as text response (defaults to `text/plain`).
 */
function sendText(req, payload, options = {}) {
    const contentType = options.contentType || "text/plain";
    return send(req, payload, Object.assign({}, options, { contentType }));
}
exports.sendText = sendText;
/**
 * Send as html response (`text/html`).
 */
function sendHtml(req, payload, options = {}) {
    const contentType = options.contentType || "text/html";
    return send(req, payload, Object.assign({}, options, { contentType }));
}
exports.sendHtml = sendHtml;
/**
 * Generate the response for Servie.
 */
function send(req, payload, options = {}) {
    let status = options.status || 200;
    let body = req.method === "HEAD" ? undefined : payload;
    const headers = new node_1.Headers(options.headers);
    const { mtime, contentType, contentLength } = options;
    const etag = computeEtag(body, options.etag);
    if (fresh(req, etag, mtime)) {
        status = 304;
        body = undefined;
    }
    else {
        if (contentType)
            headers.set("Content-Type", contentType);
        if (contentLength)
            headers.set("Content-Length", String(contentLength));
    }
    if (etag)
        headers.set("ETag", etag);
    if (mtime)
        headers.set("Last-Modified", mtime.toUTCString());
    return new node_1.Response(body, { status, headers });
}
exports.send = send;
/**
 * Compute etags when requested.
 */
function computeEtag(body, etag) {
    if (typeof etag === "string")
        return etag;
    if (!etag)
        return;
    if (body === undefined || body === null)
        return ZERO_LENGTH_ENTITY_TAG;
    if (typeof body === "string" || Buffer.isBuffer(body))
        return entityTag(body);
    throw new TypeError("Etag can only be computed on a string or buffer");
}
/**
 * Create an ETag from the payload body.
 */
function entityTag(body) {
    return body.length === 0 ? ZERO_LENGTH_ENTITY_TAG : toEntityTag(body);
}
exports.entityTag = entityTag;
/**
 * Create an entity tag for cache identification.
 */
function toEntityTag(body) {
    const hash = crypto_1.createHash("sha256")
        .update(body)
        .digest("base64");
    return `"${hash}"`;
}
/**
 * Check if a request is fresh.
 *
 * Reference: https://github.com/jshttp/fresh
 */
function fresh(req, etag, mtime) {
    const ifNoneMatch = req.headers.get("if-none-match");
    const ifModifiedSince = req.headers.get("if-modified-since");
    if (!ifNoneMatch && !ifModifiedSince)
        return false;
    const cacheControl = req.headers.get("cache-control");
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
    }
    if (ifNoneMatch && etag) {
        const isFresh = ifNoneMatch.split(TOKEN_LIST_REGEXP).every(match => {
            return match === etag;
        });
        if (isFresh)
            return true;
    }
    if (ifModifiedSince && mtime) {
        const isFresh = mtime.getTime() <= Date.parse(ifModifiedSince);
        if (isFresh)
            return true;
    }
    return false;
}
//# sourceMappingURL=index.js.map