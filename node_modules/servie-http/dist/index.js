"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pump = require("pump");
const node_1 = require("servie/dist/node");
const common_1 = require("servie/dist/common");
const servie_finalhandler_1 = require("servie-finalhandler");
const servie_errorhandler_1 = require("servie-errorhandler");
/**
 * Node.js HTTP request class.
 */
class HttpRequest extends node_1.Request {
    constructor(input, options) {
        super(input, options);
        this.request = options.request;
    }
}
exports.HttpRequest = HttpRequest;
/**
 * Create a node.js-compatible http handler.
 */
function createHandler(app, options = {}) {
    return function (request, response) {
        let didRespond = false;
        const req = new HttpRequest(request.url || "/", {
            method: request.method,
            body: request,
            headers: request.headers,
            omitDefaultHeaders: true,
            request: request
        });
        const mapError = servie_errorhandler_1.errorhandler(req, {
            production: options.production,
            log: options.logError
        });
        function sendError(err) {
            return sendResponse(mapError(err));
        }
        function sendResponse(res) {
            if (didRespond)
                return;
            didRespond = true;
            req.signal.emit("responseStarted");
            if (res.status)
                response.statusCode = res.status;
            if (res.statusText)
                response.statusMessage = res.statusText;
            const headers = res.headers.asObject();
            const rawBody = common_1.useRawBody(res);
            for (const key of Object.keys(headers)) {
                response.setHeader(key, headers[key]);
            }
            Promise.all([
                res.trailer.then(trailer => {
                    response.addTrailers(trailer.asObject());
                }),
                // Creating a stream is super expensive, use buffered values when possible.
                rawBody === null
                    ? new Promise(resolve => {
                        req.signal.emit("responseEnded");
                        response.end();
                        return resolve();
                    })
                    : Buffer.isBuffer(rawBody) || typeof rawBody === "string"
                        ? new Promise(resolve => {
                            response.write(rawBody);
                            response.end();
                            req.signal.emit("responseEnded");
                            return resolve();
                        })
                        : new Promise((resolve, reject) => {
                            pump(rawBody, response, err => {
                                req.signal.emit("responseEnded");
                                return err ? reject(err) : resolve();
                            });
                        })
            ]).catch(sendError);
        }
        req.signal.on("abort", () => request.destroy());
        req.signal.emit("requestStarted");
        return Promise.resolve(app(req, servie_finalhandler_1.finalhandler(req))).then(res => sendResponse(res), err => sendError(err));
    };
}
exports.createHandler = createHandler;
//# sourceMappingURL=index.js.map