"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("servie/dist/node");
const servie_route_1 = require("servie-route");
const throwback_1 = require("throwback");
const fs_1 = require("fs");
const http = require("http");
const path_1 = require("path");
const index_1 = require("./index");
describe("servie-http", () => {
    const handler = index_1.createHandler(throwback_1.compose([
        servie_route_1.get("/", () => {
            return new node_1.Response("hello world");
        }),
        servie_route_1.get("/stream", () => {
            return new node_1.Response(fs_1.createReadStream(path_1.join(__dirname, "index.ts")), {
                headers: {
                    Trailer: "Server-Timing"
                },
                trailer: {
                    "Server-Timing": "end=100"
                }
            });
        })
    ]));
    const server = http.createServer(handler).listen(0);
    const address = server.address();
    const url = typeof address === "string" ? address : `http://localhost:${address.port}`;
    afterAll(() => server.close());
    it("should work over http", done => {
        return http.get(url, res => {
            let data = "";
            res.on("data", (chunk) => (data += chunk.toString("utf8")));
            res.on("end", () => {
                expect(res.headers["content-type"]).toEqual("text/plain");
                expect(res.headers["content-length"]).toEqual("11");
                expect(data).toBe("hello world");
                return done();
            });
        });
    });
    it("should send trailers", done => {
        return http.get(`${url}/stream`, res => {
            res.resume();
            res.on("end", () => {
                expect(res.trailers).toEqual({ "server-timing": "end=100" });
                return done();
            });
        });
    });
});
//# sourceMappingURL=index.spec.js.map