"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("servie/dist/node");
const common_1 = require("servie/dist/common");
const path_to_regexp_1 = require("path-to-regexp");
const servie_url_1 = require("servie-url");
const popsicle_transport_http_1 = require("popsicle-transport-http");
/**
 * Create a simple service to proxy requests.
 */
class Service {
    constructor(config) {
        const { path, methods, url, newPath, end, start, sensitive } = config;
        this.re = path_to_regexp_1.pathToRegexp(path || "/", undefined, {
            strict: true,
            start,
            end,
            sensitive
        });
        this.methods = new Set((methods || []).map(x => x.toLowerCase()));
        this.url = url;
        this.newPath = newPath;
    }
    isMethod(method) {
        return this.methods.size === 0 || this.methods.has(method.toLowerCase());
    }
    isPath(path) {
        return this.re.test(path);
    }
    matches(url, method) {
        return this.isMethod(method) && this.isPath(url.pathname);
    }
    getPath(path) {
        if (!this.newPath)
            return path;
        return path.replace(this.re, this.newPath);
    }
    getUrl(url) {
        return `${this.url}${this.getPath(url.pathname)}${url.search}${url.hash}`;
    }
}
exports.Service = Service;
/**
 * Proxy any number of paths to services.
 */
function proxy(configs, send = popsicle_transport_http_1.transport()) {
    const services = configs.map(config => new Service(config));
    return (req, next) => __awaiter(this, void 0, void 0, function* () {
        const url = servie_url_1.getURL(req);
        for (const service of services) {
            if (service.matches(url, req.method)) {
                const proxyReq = new node_1.Request(service.getUrl(url), {
                    method: req.method,
                    headers: req.headers,
                    signal: req.signal,
                    omitDefaultHeaders: true,
                    body: common_1.useRawBody(req),
                    trailer: req.trailer
                });
                return send(proxyReq, () => {
                    throw new TypeError("Unhandled proxy request");
                });
            }
        }
        return next(); // 404.
    });
}
exports.proxy = proxy;
//# sourceMappingURL=index.js.map